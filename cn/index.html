<!DOCTYPE html>
<html lang="en">
<head>
    <title>node-odata Documentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" href="index.css">
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
</head>
<body>
<div id="header">
    <h1>node-odata Documentation</h1>
</div>

    <div id="sidebar">
<ul>
  <li><div><a href="#1">1) 安装</a></div></li>
  <li><div><a href="#2">2) 快速开始</a></div>
  <ul>
    <li><div><a href="#21">2.1 创建服务</a></div></li>
    <li><div><a href="#22">2.2 运行服务</a></div></li>
  </ul></li>
  <li><div><a href="#3">3) 使用服务</a></div>
  <ul>
    <li><div><a href="#31">3.1 新增</a></div></li>
    <li><div><a href="#32">3.2 修改</a></div></li>
    <li><div><a href="#33">3.3 查询</a></div></li>
    <li><div><a href="#34">3.4 删除</a></div></li>
  </ul></li>
  <li><div><a href="#4-odata">4) OData 查询</a></div>
  <ul>
    <li><div><a href="#41-filter">4.1 $filter</a></div></li>
    <li><div><a href="#42-orderby">4.2 $orderby</a></div></li>
    <li><div><a href="#43-top">4.3 $top</a></div></li>
    <li><div><a href="#44-skip">4.4 $skip</a></div></li>
    <li><div><a href="#45-select">4.5 $select</a></div></li>
    <li><div><a href="#46-count">4.6 $count</a></div></li>
    <li><div><a href="#47-metadata">4.7 $metadata</a></div></li>
  </ul></li>
  <li><div><a href="#5-api">5) API</a></div>
  <ul>
    <li><div><a href="#51-resource">5.1 Resource</a></div></li>
    <li><div><a href="#52-function">5.2 Function</a></div></li>
    <li><div><a href="#53-set-get">5.3 set / get</a></div></li>
    <li><div><a href="#54-use">5.4 use</a></div></li>
    <li><div><a href="#55-listen">5.5 listen</a></div></li>
  </ul></li>
</ul>

    </div>
    <div id="content">

<h1>关于 node-odata</h1>
<div class="intro">


<p>node-odata 可以让你轻松创建 REST API, 并能使用 <a href="http://www.odata.org/">OData</a> 协议对资源进行的查询. 它能让你以极简的方式来创建 API 服务, 使你更专注于业务逻辑的处理.</p>

<h2>什么是 OData 协议?</h2>

<p>OData 全名"开放数据协议(Open Data Protocol)", 是一个用于 web 的数据访问协议. OData 提供了一个统一的 CRUD (create, read, update, and delete) 操作来查询和维护数据集.</p>

<h2>为什么使用 node-odata?</h2>

<p>node-odata 同时结合了 OData 强大的数据查询能力以及 NodeJS 支持高并发的优势, 使开发者能快速的创建一个高性能并支持各种复杂查询的 REST API.</p>

<p>在常规的 REST 框架中, 其只提供了 REST 风格的 CRUD 操作. 开发者不得不对每一个资源都手动添加一些公共功能, 如排序/分页等. 甚至在多数复杂的业务场景中, 开发者需要一次次根据业务需求定制出特定的复杂查询 API, 这都极大的浪费了人力资源. OData数据访问协议很好的解决了这一问题. 它定义了$filter, $orderby, $select等一系列关键字来进行统一的筛选, 排序, 分页等操作. 极大的减轻了开发者的负担, 提高了生产力.</p>

<p>反观 OData 社区, 目前 node-odata 是唯一一款基于 NodeJS 的服务端 OData 框架. 与其它编译型语言的 OData 实现相比, 它运行更加高效, 部署更加方便, 编写更加简单 (4行代码即可初始化一个 OData 服务).</p>

<h2>当前状态</h2>

<p>node-odata 当前处于测试版中, 它是稳定的但并不完整. node-odata 基于 ECMAScript6 编写, 使用 babel 便以为 ECMAScript5 后发布. 它目前需要依赖特定数据库: MongoDB. 当前的目标是完成 OData 协议中得所有特性, 然后制作链接到其它数据库的 Adapter.</p>


</div>
<h1 id="1">1) 安装</h1>

<p>node-odata 的运行需要依赖于 <a href="http://nodejs.org/">NodeJS</a> 和 <a href="http://www.mongodb.org/">MongoDB</a>, 在安装了依赖项之后, 运行以下命令即可:</p>

<pre class="shell"><code>npm install node-odata
</code></pre>

<h1 id="2">2) 快速开始</h1>

<p>这里我们将创建并运行一个最简单的 OData 服务.</p>

<h2 id="21">2.1 创建服务</h2>

<p><strong>node-odata</strong> 安装完成后, 新建 <em>index.js</em> 文件并输入以下脚本:</p>

<pre><code>var odata = require('node-odata');

var server = odata('mongodb://localhost/my-app');

server.resource('books', { title: String, price: Number });

server.listen(3000);
</code></pre>

<h2 id="22">2.2 运行服务</h2>

<p>保存后输入以下命令即可启动 OData 服务:</p>

<pre class="shell"><code>node index.js
</code></pre>

<p>它将自动注册以下路由:</p>

<pre><code>GET    /books
GET    /books(:id)
POST   /books
PUT    /books(:id)
DELETE /books(:id)
</code></pre>

<h1 id="3">3) 使用服务</h1>

<p>你可以使用 <a href="http://zh.wikipedia.org/wiki/REST">REST</a> 风格的 HTTP 请求来对资源进行增删查改操作.</p>

<h2 id="31">3.1 新增</h2>

<p>使用 <strong>POST /resource</strong> 插入新的数据, 它将返回 resource 的最新状态.</p>

<pre class="shell"><code>curl -i -X POST -d '{"title": "title of book", "price": 19.99}' -H "Content-Type: application/json" http://127.0.0.1:3000/books
HTTP/1.1 201 Created
Content-Type: application/json; charset=utf-8
Content-Length: 83
Date: Sun, 11 Jan 2015 01:46:57 GMT
Connection: keep-alive

{
  "title": "title of book",
  "price": 19.99,
  "id": "44cc0da1-7372-43ed-a514-98d5fd6d8498"
}
</code></pre>

<h2 id="32">3.2 修改</h2>

<p>使用 <strong>PUT /resource(:id)</strong> 修改已有的数据, 它将返回 resource 修改后的状态.</p>

<pre class="shell"><code>curl -i -X PUT -d '{"title": "title of book", "price": 9.99}' -H "Content-Type: application/json" http://127.0.0.1:3000/books(44cc0da1-7372-43ed-a514-98d5fd6d8498)
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 82
Date: Sun, 11 Jan 2015 01:50:11 GMT
Connection: keep-alive

{
  "title": "title of book",
  "price": 9.99,
  "id": "44cc0da1-7372-43ed-a514-98d5fd6d8498"
}
</code></pre>

<h2 id="33">3.3 查询</h2>

<p>使用 <strong>GET /resource</strong> 查询 resource 列表, 其结果将以数组的形式返回在 value 中.</p>

<pre class="shell"><code>curl -i -X GET http://127.0.0.1:3000/books
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 94
Date: Sun, 11 Jan 2015 01:52:49 GMT
Connection: keep-alive

{
  "value": [
    {
      "id": "44cc0da1-7372-43ed-a514-98d5fd6d8498",
      "title": "title of book",
      "price": 9.99
    }
  ]
}
</code></pre>

<p>使用 <strong>GET /resource(:id)</strong> 查询特定 resource.</p>

<pre class="shell"><code>curl -i -X GET http://127.0.0.1:3000/books(44cc0da1-7372-43ed-a514-98d5fd6d8498)
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 82
Date: Sun, 11 Jan 2015 01:54:49 GMT
Connection: keep-alive

{
  "id": "44cc0da1-7372-43ed-a514-98d5fd6d8498",
  "title": "title of book",
  "price": 9.99
}
</code></pre>

<h2 id="34">3.4 删除</h2>

<p>使用 <strong>DELETE /resource(:id)</strong> 删除指定 resource.</p>

<pre class="shell"><code>curl -i -X DELETE http://127.0.0.1:3000/books(44cc0da1-7372-43ed-a514-98d5fd6d8498)
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 0
Date: Sun, 11 Jan 2015 01:56:21 GMT
Connection: keep-alive
</code></pre>

<h1 id="4-odata">4) OData 查询</h1>

<p>本节将介绍如何使用 OData 协议进行数据集的查询. 查询是通过一个特定的 URL 来进行的, 你可以对数据集进行如 过滤, 排序, 分页等. 每个关键字都有相同的 ($) 字符作为前缀.</p>

<p>每个关键字只能指定一次.</p>

<h2 id="41-filter">4.1 $filter</h2>

<p><strong>$filter</strong> 关键字可以对返回的数据集进行筛选.</p>

<p>如: 返回价格低于 10 元的书单列表</p>

<pre><code>http://host/books?$filter=price lt 10.00
</code></pre>

<p>下方表格中列出了 node-odata 已支持的操作符:</p>

<table>
<tbody>
<tr><td><strong>操作符</strong></td><td><strong>描述</strong></td><td><strong>列子</strong></td></tr>
<tr><td><strong>比较操作符</strong></td><td></td><td></td></tr>
<tr><td>eq</td><td>等于 (Equal)</td><td>genre eq  'Fantasy'</td></tr>
<tr><td>ne</td><td>不等于 (Not equal)</td><td>author ne 'Kevin Kelly'</td></tr>
<tr><td>gt</td><td>大于 (Greater than)</td><td>price gt 20</td></tr>
<tr><td>ge</td><td>大于等于 (Greater than or equal)</td><td>price ge 10</td></tr>
<tr><td>lt</td><td>小于 (Less than)</td><td>price lt 20</td></tr>
<tr><td>le</td><td>小于等于 (Less than or equal)</td><td>price le 100</td></tr>
<tr><td><strong>逻辑操作符</strong></td><td></td><td></td></tr>
<tr><td>and</td><td>逻辑与 (Logical and)</td><td>Price le 200 and Price gt 3.5</td></tr>
</tbody>
</table>

<p>node-odata 还内置了一些函数, 用于支持复杂查询. 如下表所示:</p>

<table>
<tbody>
<tr><td><strong>函数</strong></td><td><strong>列子</strong></td></tr>
<tr><td><strong>字符串函数</strong></td><td></td></tr>
<tr><td>contains</td><td>contains('Alfreds',CompanyName)</td></tr>
<tr><td>indexof</td><td>indexof(description,'.NET') gt 0</td></tr>
</tbody>
</table>

<table>
<tbody>
<tr><td><strong>日期函数</strong></td><td></td></tr>
<tr><td>year</td><td>year(publish_date) eq 2000</td></tr>
</tbody>
</table>

<p>*Note: 更多地操作符和函数将在未来实现. OData 协议中定义的所有操作符和函数请参考<a href="http://docs.oasis-open.org/odata/odata/v4.0/odata-v4.0-part1-protocol.html#_Toc406398301">这里</a>.</p>

<h2 id="42-orderby">4.2 $orderby</h2>

<p><strong>$orderby</strong> 关键字可以使返回的数据依据集合中特定字段进行排序.</p>

<p>它可以使用逗号分隔以实现多重排序.</p>

<p>表达式可以以 <code>asc</code> 或 <code>desc</code> 结尾用于表示升序或降序. 如果不提供, 默认则为 <code>asc</code>.</p>

<p>如: 根据书的发行日期从老到新排序, 然后在根据书的价格从高到低排序.</p>

<pre><code>http://host/books?$orderby=publish_date asc, price desc
</code></pre>

<h2 id="43-top">4.3 $top</h2>

<p><strong>$top</strong> 关键字用于限制返回集合的条数.</p>

<p>如: 从书单中返回前5本书</p>

<pre><code>http://host/books?$top=5
</code></pre>

<h2 id="44-skip">4.4 $skip</h2>

<p><strong>$skip</strong> 关键字用于排除结果中的前 n 条记录, 返回的数据集将从第 n+1 条的位置开始.</p>

<p>如: 返回书单中第6条和第6条以后的数据</p>

<pre><code>http://host/books?$skip=6
</code></pre>

<p>当 $top 和 $skip 同时使用时, 无论它们在 URL 中的顺序如何, $skip 总是会优先执行. 你可以用它们实现分页功能.</p>

<p>如: 返回第3到第7条数据</p>

<pre><code>http://host/books?$top=5&amp;$skip=2
</code></pre>

<h2 id="45-select">4.5 $select</h2>

<p><strong>$select</strong> 关键字用于让客户端指定 resource 仅需返回的字段. 多个字段之间使用逗号分隔.</p>

<p>如: 仅返回书的名字和价格</p>

<pre><code>http://host/books?$select=title, price
</code></pre>

<h2 id="46-count">4.6 $count</h2>

<p>当指定 <strong>$count</strong> 关键字的值为 <code>true</code> 的时候, 它将返回当前查询数据集的总条数.</p>

<p><strong>$count</strong> 关键字将忽略 <strong>$top</strong> 和 <strong>skip</strong> 的过滤条件, 它的结果只受 <strong>$filter</strong> 的影响.</p>

<p>如: 返回书单列表, 并包含总条数数量</p>

<pre><code>http://host/books?$count=true
</code></pre>

<h2 id="47-metadata">4.7 $metadata</h2>

<p>TODO</p>

<h1 id="5-api">5) API</h1>

<p>本节将介绍 node-odata 提供的 <strong>fluent API</strong>.</p>

<h2 id="51-resource">5.1 Resource</h2>

<p>在 OData 服务中注册一个 Resource, 使其可以使用基于 OData 的 REST API 进行增删查改.</p>

<h3>参数</h3>

<table>
<tbody>
<tr><td><strong>Name</strong></td><td><strong>Type</strong></td><td><strong>Details</strong></td></tr>
<tr><td>url</td><td>string</td><td>Resource 的 URL 地址</td></tr>
<tr><td>model</td><td>object</td><td>Resource 的数据结构定义</td></tr>
</tbody>
</table>

<h3 id="example">example</h3>

<p><strong>注</strong>: 除了 url 和 model 以外, 其它都是可选配置</p>

<pre><code>server.resource('book', {
  // Resource 的数据结构定义
  // 可选类型包括: String, Number, Date, Boolean, Array
  author: String,
  description: String,
  genre: String,
  id: String,
  price: Number,
  publish_date: Date,
  title: String
})
// 配置 GET /resource(:id)
.get()
  .auth(function (req) {...}) // 授权验证, 若返回 false, 则客户端将得到 401
  .before(function (entity) {...}) // 在请求前执行的 callback
  .after(function (entity) {...}) //在请求完成后执行的 callback
// 配置 GET /resource
.list()
  .auth(function (req) {...})
  .before(function () {...})
  .after(function (data) {...})
// 配置 POST /resource
.post()
  .auth(function (req) {...})
  .before(function (entity) {...})
  .after(function (originEntity, newEntity) {...})
// 配置 PUT /resource(:id)
.put()
  .auth(function (req) {...})
  .before(function (entity) {...})
  .after(function (entity) {...})
// 配置 DELETE /resource(:id)
.delete()
  .auth(function (req) {...})
  .before(function (entity) {...})
  .after(function (entity) {...})
// 配置上述所有请求
.all()
  .auth(function (req) {...})
  .before(function (entity) {...})
  .after(function (entity) {...})
// 设置 OData Action
// 第一个参数为 action url, 第二个参数为 callback
// 请求方式为 POST /resource(:id)/50-off
.action('/50off', function(req, res, next){...})
// 默认排序字段, 默认为 undefined
.orderBy('date desc') 
// 最大允许跳过的行数, 默认为不限制
.maxSkip(10000) 
// 最大允许一次返回的条数, 默认为不限制
.maxTop(100)
</code></pre>

<h2 id="52-function">5.2 Function</h2>

<p>在 OData 中注册一个 WEB API, 用于处理自定义的逻辑.</p>

<pre><code>server.get(url, callback, auth);
server.put(url, callback, auth);
server.post(url, callback, auth);
server.delete(url, callback, auth);
</code></pre>

<h3 id="-2">参数</h3>

<table>
<tbody>
<tr><td><strong>Name</strong></td><td><strong>Type</strong></td><td><strong>Details</strong></td></tr>
<tr><td>url</td><td>string</td><td>WEB API 的 URL 地址</td></tr>
<tr><td>callback</td><td>function</td><td>具体处理逻辑</td></tr>
<tr><td>auth</td><td>function (optional)</td><td>权限验证</td></tr>
</tbody>
</table>

<h4 id="example-2">Example</h4>

<pre><code>odata.get('/server-time', function(req, res, next) {
  res.json({
    date: new Date()
  });
});
</code></pre>

<h2 id="53-set-get">5.3 set / get</h2>

<p>用于对 node-odata 进行一些基本配置.</p>

<table>
<tbody>
<tr><td><strong>Allow Key</strong></td><td><strong>Value Type</strong></td><td><strong>Details</strong></td></tr>
<tr><td>db</td><td>string</td><td>重新配置 mongoDB 数据库地址</td></tr>
<tr><td>prefix</td><td>string</td><td>重新配置 URL 前缀, 默认为 '/'</td></tr>
<tr><td>maxTop</td><td>int</td><td>设置全局最大允许查询的条数</td></tr>
<tr><td>maxSkip</td><td>int</td><td>设置全局最大允许跳过的条数</td></tr>
</tbody>
</table>

<h2 id="54-use">5.4 use</h2>

<p>使用 <code>server.use</code> 可添加 <strong>Express</strong> 中间件.</p>

<h2 id="55-listen">5.5 listen</h2>

<p>在给定的主机和端口上监听请求.</p>

    </div> <!-- #content -->
<script type="text/javascript" charset="utf-8">
$(function() {
    var headerHeight = $("#header").height();

    var sections = $("#content h1[id], #content h2[id]");
    var sectionOffsets = [];
    var slack = 100;  // Give the section scroll some slack (in pixels).
    sections.each(function(elem) {
        sectionOffsets.push($(this).offset().top - headerHeight - slack);
    });

    var currSectionIdx = -1;
    function getSectionIdx(scrollDistance) {
        if (scrollDistance < sectionOffsets[0]) {
            return -1;
        } else {
            for (var id = sectionOffsets.length; id > 0; id--) {
                if (scrollDistance > sectionOffsets[id - 1]) {
                    return id - 1;
                    break;
                }
            }
        }
    }

    /** {{{ http://code.activestate.com/recipes/577787/ (r2) */
    _slugify_strip_re = /[^\w\s-]/g;
    _slugify_hyphenate_re = /[-\s]+/g;
    function slugify(s) {
      s = s.replace(_slugify_strip_re, '').trim().toLowerCase();
      s = s.replace(_slugify_hyphenate_re, '-');
      return s;
    }
    /** end of http://code.activestate.com/recipes/577787/ }}} */

    /* See <https://github.com/trentm/restdown/issues/11>. */
    function safechars(s) {
      return s.replace(_slugify_strip_re, '');
    }

    $("#content").scroll(function() {
        var scrollDistance = $("#content").scrollTop();
        var sectionIdx = getSectionIdx(scrollDistance);

        if (sectionIdx !== currSectionIdx) {
            $("#sidebar li>div").removeClass("current");
            currSectionIdx = sectionIdx;
            if (currSectionIdx >= 0) {
                var heading = $(sections[currSectionIdx]).text();
                var possibleAnchors = [
                    slugify(heading), // h1 or non-method h2
                    heading.replace(/ /g, '-'), // h2 method, just name or just endpoint
                    heading.slice(0, heading.lastIndexOf(' (')).trimRight().replace(/ /g, '-'), // h2 method, name and endpoint
                ];
                for (var i=0; i < possibleAnchors.length; i++) {
                    var anchor = safechars(possibleAnchors[i]);
                    try {
                        $("#sidebar a[href=#" + anchor + "]").parent().addClass("current");
                    } catch (e) {
                        /* Ignore error if no such element. */
                        console.log(e)
                    }
                }
            }
        }
    });
});
</script>

</body>
</html>
